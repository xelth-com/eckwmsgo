# AI Instructions

## 1. How to Read This Snapshot

This document is a self-contained, single-file snapshot of the **eckwmsgo** software repository, generated by the `eck-snapshot` tool on **9.1.2026, 04:03:22**. It is designed to provide a Large Language Model (LLM) with the complete context of a project.

* **Source of Truth:** Treat this snapshot as the complete and authoritative source code.
* **Structure:** The file contains a **Directory Structure** tree, followed by the full content of each file, demarcated by `--- File: /path/to/file ---` headers.

**Snapshot Stats:**
- **Files Included:** 29
- **Total Files in Repo:** 29

---

## 2. Your Core Operational Workflow

You are the Project Manager and Solution Architect AI. Your primary goal is to translate user requests into technical plans and then generate precise commands for code-execution AI agents.

### PROJECT OVERVIEW
- **Project:** eckwmsgo
- **Description:** (Placeholder: A go project)



## Project Context (.eck Directory)

This project has a `.eck/` directory with project-specific context files.
The coder agent can read these files when needed. Available files:

- `CONTEXT.md` - Project overview and architecture
- `OPERATIONS.md` - Common commands and workflows
- `JOURNAL.md` - Development history
- `ROADMAP.md` - Planned features
- `TECH_DEBT.md` - Known issues and refactoring needs
- `ENVIRONMENT.md` - Environment-specific settings

### Recent Development Activity

**Latest Entry** (no date):
- Type: `unknown` | Scope: ``
- 
  type: feat
  scope: main
  summary: Enable automatic database migrations on startup
  date: 2026-01-08

**Previous entries:**
- `unknown()`: 
- `unknown()`: 
- `unknown()`: 

---



### üõ† MANIFEST MAINTENANCE PROTOCOL (CRITICAL)

The `.eck/` directory files are your "Source of Knowledge".
1. **Stub Detection:** If a file starts with `# [STUB: ...]`, it means the system failed to auto-generate meaningful content.
2. **Architect's Duty:** You **MUST NOT** ignore stubs. Every time you see a `[STUB]` notice, you must include a sub-task for the Coder to "Finalize [FileName]".
3. **Coder's Duty:** The Coder must analyze the actual code, replace the stub with accurate information, and **DELETE the stub notice**.

**Documentation is part of the "Definition of Done". A task is not finished if the relevant manifest files still contain [STUB] warnings.**

### CRITICAL WORKFLOW: Structured Commits via `journal_entry`

To ensure proper project history, all code changes **MUST** be committed using the project's built-in structured workflow.

**Your Role (Architect):**
Your JSON command payload **MUST** include a `post_execution_steps.journal_entry` object. This object is the *trigger* for the execution agent's internal `/eck:commit` command.

**DO NOT** generate `git add` or `git commit` commands yourself. The `journal_entry` object handles everything:
1.  Staging all changes (`git add .`).
2.  Creating a YAML frontmatter entry for the journal.
3.  Prepending the entry to `.eck/JOURNAL.md`.
4.  Executing the conventional Git commit.

**Example `journal_entry` in your payload:**
```json
    "post_execution_steps": {
      "journal_entry": {
        "type": "feat",
        "scope": "api",
        "summary": "Implement user authentication endpoint",
        "details": "- Added /login route\n- Implemented JWT validation"
      }
    }
````

### Strategic Manifest Files

As the Architect, you are also responsible for maintaining other strategic files in the `.eck` directory, such as `ROADMAP.md` and `TECH_DEBT.md`. Propose modifications to these files as needed to reflect the project's status.

### .eck Documentation Review Protocol

**IMPORTANT:** The `.eck` directory contains essential project documentation. Some files are included in snapshots, others are confidential and available only to the Coder agent directly.

**Files included in this snapshot (for Architect reference):**
- `ARCHITECTURE.md` - System architecture documentation
- `CONTEXT.md` - Project context and overview
- `OPERATIONS.md` - Operational procedures
- `ROADMAP.md` - Project roadmap and milestones
- `TECH_DEBT.md` - Technical debt tracking

**Confidential files (NOT in snapshot, but Coder can read directly):**
- `SERVER_ACCESS.md` - Server credentials, SSH access, PM2 commands, database connections
- `CREDENTIALS*.md` - API keys, tokens, passwords
- `SECRETS*.md` - Other sensitive configuration

**CRITICAL: Instructions for Coder agent:**
When generating commands for the Coder agent (Claude Code), you MUST include this instruction:

> "Before starting, list all files in `.eck/` directory and read any that may be relevant to this task. File names indicate their content (e.g., SERVER_ACCESS.md contains server access info, OPERATIONS.md contains operational procedures). You decide what you need based on the task."

The Coder agent is intelligent and will understand what information they need based on file names.

**Maintain Documentation:** When assigning tasks, instruct the Coder to update relevant `.eck/` documentation files if the changes affect:
- System architecture (update `ARCHITECTURE.md`)
- Operational procedures (update `OPERATIONS.md`)
- Technical debt status (update `TECH_DEBT.md`)
- Project roadmap progress (update `ROADMAP.md`)

### CORE WORKFLOW: The Interactive Command Cycle

1.  **Check Environment:** Request ENV scan from agent first
2.  **Analyze User Request:** Understand the user's goal in their native language.
3.  **Formulate a Plan:** Create a high-level technical plan appropriate for the detected environment and .eck manifest context.
4.  **Propose & Await Confirmation:** Present the plan to the user in their language and ask for approval to generate the command. **CRITICAL: Stop and wait for the user's response. Do NOT generate the command block at this stage.**
5.  **Generate Command on Demand:** This is the execution step, triggered ONLY by a positive user response.
      - **On Approval:** If the user confirms the plan (e.g., "yes", "proceed") or provides a minor correction, your *next response* must be **only the command block**. Do not include any conversational text.
      - **On Direct Order:** If the user explicitly asks for the command (e.g., "make the command for Claude now") and you have all the necessary information, you may skip step 3 and directly generate the command block.
6.  **Review & Report:** After the command is executed, analyze the results and report back to the user in their language.
7.  **Iterate:** Continue the cycle based on user feedback.

### AGENT WORKFLOW

Your role is **Architect**. You formulate technical plans and delegate code implementation tasks directly to the **Coder** agents.

**Your secondary duty is DOCUMENTATION INTEGRITY.** You must ensure the Coder updates .eck/ files whenever the project structure, roadmap, or debt changes.

  - **Architect (You):** Sets strategy, defines tasks, enforces manifest maintenance.
  - **Coder (e.g., `local_dev`):** Receives precise coding tasks and executes them, including manifest updates.

### COMMAND FORMATS (Eck-Protocol v2)

You MUST use the **Eck-Protocol v2** format for all code execution tasks. This format combines Markdown for analysis, XML tags for file operations, and JSON for routing metadata.

**CRITICAL DISPLAY RULE (THE 4-BACKTICK WRAPPER):**
To ensure your command is copy-pasteable without breaking UI rendering, you **MUST** wrap the ENTIRE protocol output in a `text` block using **QUADRUPLE BACKTICKS** (` ```` `).

**Why?** Your command contains internal code blocks with 3 backticks. To escape them, the outer container needs 4.

**Required Output Format:**

````text
# Analysis
[Your reasoning...]

## Changes
<file path="example.js" action="replace">
\`\`\`javascript
// Internal code block uses 3 backticks
const x = 1;
\`\`\`
</file>

## Metadata
\`\`\`json
{ ... }
\`\`\`
````

**File Actions:**
- `create`: Create a new file (requires full content)
- `replace`: Overwrite existing file (requires full content)
- `modify`: Replace specific sections (provide context)
- `delete`: Delete the file


### COMMUNICATION PROTOCOL

  - **User Interaction:** ALWAYS communicate with the user in the language they use.
  - **Agent Commands:** ALWAYS formulate the JSON payload and technical instructions for the execution agent in **ENGLISH** to ensure technical accuracy.
  - **Context Integration:** When briefing agents, include relevant information from the .eck manifest to provide better context.

### AVAILABLE EXECUTION AGENTS

You can command multiple specialized agents. **YOU must choose the most appropriate agent** based on the task requirements and target environment:


### Local Terminal (Sonnet 4.5) (ID: "local_dev")
- **Description:** Direct execution interface. Use for quick commands.
- **GUI Support:** Yes
- **Capabilities:** npm, git, basic editing
- **Restrictions:** Do not use for complex architectural tasks

### Production Server Agent (AGENT_PROD_SERVER) (ID: "production_server")
- **Description:** Linux production server with PostgreSQL and PM2, with development capabilities
- **GUI Support:** No (Headless)
- **Capabilities:** pm2 restart/reload/stop/start, postgresql queries, knex migrations --env production, systemctl, log analysis, nginx operations, deployment scripts, file editing, npm install, git operations
- **Restrictions:** no electron, no GUI apps, no direct DB schema changes without migrations, always backup before migrations

### Android WSL Development Agent (AGENT_ANDROID_WSL) (ID: "android_wsl_dev")
- **Description:** Android development in Windows Subsystem for Linux with Gradle and ADB support
- **GUI Support:** No (Headless)
- **Capabilities:** ./gradlew build, ./gradlew assembleDebug, ./gradlew assembleRelease, ./gradlew clean, ./gradlew lint, ./gradlew test, adb devices, adb install, adb logcat, adb shell, git operations, file editing, gradle tasks, gradle wrapper operations
- **Restrictions:** no direct GUI access (Android Studio), requires /mnt/c/ path for Windows file system access, no Android emulator control (emulator runs on Windows host), limited USB device access through WSL, no hardware debugging interfaces



## Directory Structure

```
‚îú‚îÄ‚îÄ .eck/
‚îÇ   ‚îî‚îÄ‚îÄ snapshots/
‚îú‚îÄ‚îÄ cmd/
‚îÇ   ‚îî‚îÄ‚îÄ api/
‚îÇ       ‚îî‚îÄ‚îÄ main.go
‚îú‚îÄ‚îÄ internal/
‚îÇ   ‚îú‚îÄ‚îÄ config/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ config.go
‚îÇ   ‚îú‚îÄ‚îÄ database/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ database.go
‚îÇ   ‚îú‚îÄ‚îÄ handlers/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ auth.go
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ rma.go
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ router.go
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ setup.go
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ warehouse.go
‚îÇ   ‚îú‚îÄ‚îÄ middleware/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ auth.go
‚îÇ   ‚îú‚îÄ‚îÄ models/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ device.go
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ item.go
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ rma.go
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ user.go
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ warehouse.go
‚îÇ   ‚îú‚îÄ‚îÄ services/
‚îÇ   ‚îú‚îÄ‚îÄ utils/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ auth_test.go
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ auth.go
‚îÇ   ‚îî‚îÄ‚îÄ websocket/
‚îÇ       ‚îú‚îÄ‚îÄ client.go
‚îÇ       ‚îî‚îÄ‚îÄ hub.go
‚îú‚îÄ‚îÄ pkg/
‚îú‚îÄ‚îÄ web/
‚îÇ   ‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ routes/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ +layout.js
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ +page.svelte
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ app.html
‚îÇ   ‚îú‚îÄ‚îÄ efs.go
‚îÇ   ‚îú‚îÄ‚îÄ go.mod
‚îÇ   ‚îú‚îÄ‚îÄ package.json
‚îÇ   ‚îú‚îÄ‚îÄ svelte.config.js
‚îÇ   ‚îî‚îÄ‚îÄ vite.config.js
‚îú‚îÄ‚îÄ CLAUDE.md
‚îú‚îÄ‚îÄ go.mod
‚îî‚îÄ‚îÄ QUICKSTART.md
```

--- File: /CLAUDE.md ---

# üõ†Ô∏è ROLE: Expert Developer (The Fixer)

## CORE DIRECTIVE
You are an Expert Developer. The architecture is already decided. Your job is to **execute**, **fix**, and **polish**.

## DEFINITION OF DONE (CRITICAL)
When the task is complete:
1. **UPDATE** the `.eck/AnswerToSA.md` file with your status.
2. **CALL** the tool `eck_finish_task` to commit and sync context.
3. **DO NOT** use raw git commands for the final commit.

## CONTEXT
- The MiniMax swarm might have struggled or produced code that needs refinement.
- You are here to solve the hard problems manually.
- You have full permission to edit files directly.

## WORKFLOW
1.  Read the code.
2.  Fix the bugs / Implement the feature.
3.  Verify functionality (Run tests!).
4.  **Loop:** If verification fails, fix it immediately. Do not ask for permission.


--- File: /QUICKSTART.md ---

# Quick Start Guide

## –ë—ã—Å—Ç—Ä—ã–π —Å—Ç–∞—Ä—Ç –∑–∞ 3 –º–∏–Ω—É—Ç—ã

### 1. –ü—Ä–æ–≤–µ—Ä—å —Å—Ç—Ä—É–∫—Ç—É—Ä—É –ø–∞–ø–æ–∫

–î–æ–ª–∂–Ω–æ –±—ã—Ç—å —Ç–∞–∫:
```
C:\Users\Dmytro\
‚îú‚îÄ‚îÄ eckwms\          ‚Üê –û—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–π Node.js –ø—Ä–æ–µ–∫—Ç (—Ñ—Ä–æ–Ω—Ç–µ–Ω–¥)
‚îÇ   ‚îú‚îÄ‚îÄ public\      ‚Üê React —Ñ—Ä–æ–Ω—Ç–µ–Ω–¥ –∑–¥–µ—Å—å
‚îÇ   ‚îú‚îÄ‚îÄ src\
‚îÇ   ‚îî‚îÄ‚îÄ ...
‚îî‚îÄ‚îÄ eckwmsgo\        ‚Üê –ù–æ–≤—ã–π Go backend (—ç—Ç–æ—Ç –ø—Ä–æ–µ–∫—Ç)
    ‚îú‚îÄ‚îÄ cmd\
    ‚îú‚îÄ‚îÄ internal\
    ‚îú‚îÄ‚îÄ eckwmsgo.exe ‚Üê –°–∫–æ–º–ø–∏–ª–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –±–∏–Ω–∞—Ä–Ω–∏–∫
    ‚îî‚îÄ‚îÄ .env
```

### 2. –ù–∞—Å—Ç—Ä–æ–π .env

```bash
cd C:\Users\Dmytro\eckwmsgo
```

–ü—Ä–æ–≤–µ—Ä—å —á—Ç–æ –≤ `.env` –ø—Ä–∞–≤–∏–ª—å–Ω—ã–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏:
```env
# –ì–ª–∞–≤–Ω–æ–µ - –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –ë–î –¥–æ–ª–∂–Ω—ã —Å–æ–≤–ø–∞–¥–∞—Ç—å —Å Node.js –≤–µ—Ä—Å–∏–µ–π
PG_DATABASE=inbody_ai_support
PG_USERNAME=inbody_user
PG_PASSWORD=beliberdabeliberden
PG_HOST=localhost
PG_PORT=5432

# JWT —Å–µ–∫—Ä–µ—Ç
JWT_SECRET=68695b04ccf8da689a0c1fd000a05941e958bcf5d1091285400a7db43bb5402a

# Go —Å–µ—Ä–≤–µ—Ä –Ω–∞ –¥—Ä—É–≥–æ–º –ø–æ—Ä—Ç—É —á—Ç–æ–±—ã –Ω–µ –∫–æ–Ω—Ñ–ª–∏–∫—Ç–æ–≤–∞—Ç—å —Å Node.js
PORT=3001
```

### 3. –ó–∞–ø—É—Å—Ç–∏ —Å–µ—Ä–≤–µ—Ä

**–í–∞—Ä–∏–∞–Ω—Ç A: –ì–æ—Ç–æ–≤—ã–π –±–∏–Ω–∞—Ä–Ω–∏–∫ (—Å–∞–º—ã–π –ø—Ä–æ—Å—Ç–æ–π)**
```bash
cd C:\Users\Dmytro\eckwmsgo
./eckwmsgo.exe
```

**–í–∞—Ä–∏–∞–Ω—Ç B: –ß–µ—Ä–µ–∑ go run**
```bash
cd C:\Users\Dmytro\eckwmsgo
go run ./cmd/api/main.go
```

–£–≤–∏–¥–∏—à—å:
```
üöÄ Server starting on port 3001
```

### 4. –ü—Ä–æ—Ç–µ—Å—Ç–∏—Ä—É–π

–û—Ç–∫—Ä–æ–π –±—Ä–∞—É–∑–µ—Ä –∏–ª–∏ curl:

**Health check:**
```bash
curl http://localhost:3001/health
# {"status":"ok","server":"local"}
```

**API Status:**
```bash
curl http://localhost:3001/api/status
# {"status":"running","version":"1.0.0"}
```

**–§—Ä–æ–Ω—Ç–µ–Ω–¥:**
–û—Ç–∫—Ä–æ–π –≤ –±—Ä–∞—É–∑–µ—Ä–µ:
```
http://localhost:3001
```

–î–æ–ª–∂–µ–Ω –∑–∞–≥—Ä—É–∑–∏—Ç—å—Å—è React —Ñ—Ä–æ–Ω—Ç–µ–Ω–¥ –∏–∑ `../eckwms/public`

### 5. –ü–∞—Ä–∞–ª–ª–µ–ª—å–Ω–æ–µ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ

–ú–æ–∂–µ—à—å –∑–∞–ø—É—Å—Ç–∏—Ç—å –æ–±–∞ —Å–µ—Ä–≤–µ—Ä–∞ –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ:

**–¢–µ—Ä–º–∏–Ω–∞–ª 1 - Node.js (–ø–æ—Ä—Ç 3000):**
```bash
cd C:\Users\Dmytro\eckwms
npm run start:local
```

**–¢–µ—Ä–º–∏–Ω–∞–ª 2 - Go (–ø–æ—Ä—Ç 3001):**
```bash
cd C:\Users\Dmytro\eckwmsgo
./eckwmsgo.exe
```

–¢–µ–ø–µ—Ä—å —É —Ç–µ–±—è:
- Node.js API: `http://localhost:3000`
- Go API: `http://localhost:3001`
- –û–±–∞ –∏—Å–ø–æ–ª—å–∑—É—é—Ç –æ–¥–Ω—É –ë–î

## Troubleshooting

### –ü—Ä–æ–±–ª–µ–º–∞: "Failed to connect to database"
**–†–µ—à–µ–Ω–∏–µ:**
1. –ü—Ä–æ–≤–µ—Ä—å —á—Ç–æ PostgreSQL –∑–∞–ø—É—â–µ–Ω
2. –ü—Ä–æ–≤–µ—Ä—å –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –≤ `.env`
3. –ü–æ–ø—Ä–æ–±—É–π –ø–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è –∏–∑ Node.js –≤–µ—Ä—Å–∏–∏ - –µ—Å–ª–∏ —Ä–∞–±–æ—Ç–∞–µ—Ç, —Ç–æ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –ø—Ä–∞–≤–∏–ª—å–Ω—ã–µ

### –ü—Ä–æ–±–ª–µ–º–∞: –§—Ä–æ–Ω—Ç–µ–Ω–¥ –Ω–µ –∑–∞–≥—Ä—É–∂–∞–µ—Ç—Å—è (404)
**–†–µ—à–µ–Ω–∏–µ:**
1. –ü—Ä–æ–≤–µ—Ä—å —á—Ç–æ –ø–∞–ø–∫–∞ `C:\Users\Dmytro\eckwms\public` —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
2. –ï—Å–ª–∏ —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ –ø–∞–ø–æ–∫ –¥—Ä—É–≥–∞—è, –¥–æ–±–∞–≤—å –≤ `.env`:
   ```
   FRONTEND_DIR=C:/Users/Dmytro/eckwms/public
   ```

### –ü—Ä–æ–±–ª–µ–º–∞: –ü–æ—Ä—Ç –∑–∞–Ω—è—Ç
**–†–µ—à–µ–Ω–∏–µ:**
–ò–∑–º–µ–Ω–∏ –ø–æ—Ä—Ç –≤ `.env`:
```
PORT=3002
```

### –ü—Ä–æ–±–ª–µ–º–∞: "go: command not found"
**–†–µ—à–µ–Ω–∏–µ:**
Go —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –≤ `C:\Program Files\Go\bin\go.exe`
–ò—Å–ø–æ–ª—å–∑—É–π –ø–æ–ª–Ω—ã–π –ø—É—Ç—å:
```bash
/c/Program\ Files/Go/bin/go run ./cmd/api/main.go
```

## –°–ª–µ–¥—É—é—â–∏–µ —à–∞–≥–∏

–ü–æ—Å–ª–µ —Ç–æ–≥–æ –∫–∞–∫ —Å–µ—Ä–≤–µ—Ä –∑–∞–ø—É—Å—Ç–∏—Ç—Å—è:

1. **–ü—Ä–æ—Ç–µ—Å—Ç–∏—Ä—É–π API endpoints** - –∏—Å–ø–æ–ª—å–∑—É–π Postman –∏–ª–∏ curl
2. **–ü—Ä–æ–≤–µ—Ä—å —Ä–∞–±–æ—Ç—É —Å –ë–î** - —Å–æ–∑–¥–∞–π RMA, warehouse, items
3. **–°—Ä–∞–≤–Ω–∏ —Å Node.js –≤–µ—Ä—Å–∏–µ–π** - —É–±–µ–¥–∏—Å—å —á—Ç–æ –¥–∞–Ω–Ω—ã–µ —Ç–µ –∂–µ
4. **–†–∞–∑—Ä–∞–±–∞—Ç—ã–≤–∞–π –¥–∞–ª—å—à–µ**:
   - –î–æ–±–∞–≤—å JWT –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏—é
   - –†–µ–∞–ª–∏–∑—É–π middleware
   - –î–æ–±–∞–≤—å —Ç–µ—Å—Ç—ã
   - –ú–∏–≥—Ä–∏—Ä—É–π –æ—Å—Ç–∞–ª—å–Ω—ã–µ —Å–µ—Ä–≤–∏—Å—ã

## –ü–æ–ª–µ–∑–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã

```bash
# –ü–µ—Ä–µ—Å–æ–±—Ä–∞—Ç—å –±–∏–Ω–∞—Ä–Ω–∏–∫
go build -o eckwmsgo.exe ./cmd/api

# –î–æ–±–∞–≤–∏—Ç—å –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç—å
go get -u package-name

# –û–±–Ω–æ–≤–∏—Ç—å –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏
go mod tidy

# –ó–∞–ø—É—Å—Ç–∏—Ç—å —Ç–µ—Å—Ç—ã
go test ./...

# –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –∫–æ–¥
go fmt ./...
go vet ./...
```

## –ù—É–∂–Ω–∞ –ø–æ–º–æ—â—å?

- README.md - –ø–æ–ª–Ω–∞—è –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è
- internal/handlers/ - –ø–æ—Å–º–æ—Ç—Ä–∏ –∫–∞–∫ —Ä–µ–∞–ª–∏–∑–æ–≤–∞–Ω—ã endpoints
- internal/models/ - —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ –¥–∞–Ω–Ω—ã—Ö


--- File: /cmd/api/main.go ---

package main

import (
	"log"
	"net/http"
	"os"

	"github.com/dmytrosurovtsev/eckwmsgo/internal/config"
	"github.com/dmytrosurovtsev/eckwmsgo/internal/database"
	"github.com/dmytrosurovtsev/eckwmsgo/internal/handlers"
	"github.com/dmytrosurovtsev/eckwmsgo/internal/models"
)

func main() {
	// 1. Load configuration
	cfg, err := config.Load()
	if err != nil {
		log.Fatalf("Failed to load configuration: %v", err)
	}

	// 2. Initialize database (Detects Embedded vs External automatically)
	db, err := database.Connect(cfg.Database)
	if err != nil {
		log.Fatalf("Failed to connect to database: %v", err)
	}
	defer db.Close()

	// 3. Auto-Migrate Schema (Critical for Zero-Config)
	log.Println("üöÄ Synchronizing database schema...")
	err = db.AutoMigrate(
		&models.UserAuth{},
		&models.Warehouse{},
		&models.WarehouseRack{},
		&models.Place{},
		&models.Item{},
		&models.Box{},
		&models.RmaRequest{},
		&models.RepairOrder{},
		&models.ProductAlias{},
		&models.RegisteredDevice{},
	)
	if err != nil {
		log.Printf("‚ö†Ô∏è Migration warning: %v\n", err)
	} else {
		log.Println("‚úÖ Schema synchronized successfully")
	}

	// 4. Set up HTTP router
	router := handlers.NewRouter(db)

	// 5. Start server
	port := os.Getenv("PORT")
	if port == "" {
		port = "3001" // Use 3001 as default for Go version
	}

	log.Printf("üöÄ Server starting on port %s\n", port)
	if err := http.ListenAndServe(":"+port, router); err != nil {
		log.Fatalf("Failed to start server: %v", err)
	}
}


--- File: /go.mod ---

module github.com/dmytrosurovtsev/eckwmsgo

go 1.25.5

require (
	github.com/dmytrosurovtsev/eckwmsgo/web v0.0.0-00010101000000-000000000000
	github.com/fergusstrange/embedded-postgres v1.33.0
	github.com/golang-jwt/jwt/v5 v5.3.0
	github.com/gorilla/mux v1.8.1
	github.com/gorilla/websocket v1.5.3
	github.com/joho/godotenv v1.5.1
	github.com/skip2/go-qrcode v0.0.0-20200617195104-da1b6568686e
	golang.org/x/crypto v0.46.0
	gorm.io/datatypes v1.2.7
	gorm.io/driver/postgres v1.6.0
	gorm.io/gorm v1.31.1
)

require (
	filippo.io/edwards25519 v1.1.0 // indirect
	github.com/go-sql-driver/mysql v1.9.3 // indirect
	github.com/google/uuid v1.6.0 // indirect
	github.com/jackc/pgpassfile v1.0.0 // indirect
	github.com/jackc/pgservicefile v0.0.0-20240606120523-5a60cdf6a761 // indirect
	github.com/jackc/pgx/v5 v5.8.0 // indirect
	github.com/jackc/puddle/v2 v2.2.2 // indirect
	github.com/jinzhu/inflection v1.0.0 // indirect
	github.com/jinzhu/now v1.1.5 // indirect
	github.com/lib/pq v1.10.9 // indirect
	github.com/xi2/xz v0.0.0-20171230120015-48954b6210f8 // indirect
	golang.org/x/sync v0.19.0 // indirect
	golang.org/x/text v0.32.0 // indirect
	gorm.io/driver/mysql v1.6.0 // indirect
)

// Replace directive to handle local web subpackage
replace github.com/dmytrosurovtsev/eckwmsgo/web => ./web


--- File: /internal/config/config.go ---

package config

import (
	"fmt"
	"os"

	"github.com/joho/godotenv"
)

// Config holds all application configuration
type Config struct {
	NodeEnv     string
	Port        string
	JWTSecret   string
	EncKey      string
	Database    DatabaseConfig
	Translation TranslationConfig
	Server      ServerConfig
}

// DatabaseConfig holds database configuration
type DatabaseConfig struct {
	Host     string
	Port     string
	Username string
	Password string
	Database string
	Alter    bool
}

// TranslationConfig holds translation configuration
type TranslationConfig struct {
	DefaultLanguage    string
	TranslationDomain  string
	OpenAIAPIKey       string
}

// ServerConfig holds server configuration
type ServerConfig struct {
	LocalPort             string
	GlobalPort            string
	GlobalURL             string
	LocalInternalURL      string
	GlobalAPIEndpoint     string
	GlobalAPIKey          string
	InstanceID            string
	ServerPublicKey       string
	ServerPrivateKey      string
	GlobalRegisterURL     string
}

// Load loads configuration from environment variables
func Load() (*Config, error) {
	// Load .env file if it exists
	_ = godotenv.Load()

	jwtSecret := os.Getenv("JWT_SECRET")
	if jwtSecret == "" {
		return nil, fmt.Errorf("JWT_SECRET is required")
	}

	return &Config{
		NodeEnv:   getEnv("NODE_ENV", "development"),
		Port:      getEnv("PORT", "3000"),
		JWTSecret: jwtSecret,
		EncKey:    os.Getenv("ENC_KEY"),
		Database: DatabaseConfig{
			Host:     getEnv("PG_HOST", "localhost"),
			Port:     getEnv("PG_PORT", "5432"),
			Username: getEnv("PG_USERNAME", "postgres"),
			Password: os.Getenv("PG_PASSWORD"),
			Database: getEnv("PG_DATABASE", "eckwms"),
			Alter:    getEnv("DB_ALTER", "false") == "true",
		},
		Translation: TranslationConfig{
			DefaultLanguage:   getEnv("DEFAULT_LANGUAGE", "en"),
			TranslationDomain: os.Getenv("TRANSLATION_DOMAIN"),
			OpenAIAPIKey:      os.Getenv("OPENAI_API_KEY"),
		},
		Server: ServerConfig{
			LocalPort:         getEnv("LOCAL_SERVER_PORT", "3000"),
			GlobalPort:        getEnv("GLOBAL_SERVER_PORT", "8080"),
			GlobalURL:         os.Getenv("GLOBAL_SERVER_URL"),
			LocalInternalURL:  os.Getenv("LOCAL_SERVER_INTERNAL_URL"),
			GlobalAPIEndpoint: os.Getenv("GLOBAL_SERVER_API_ENDPOINT"),
			GlobalAPIKey:      os.Getenv("GLOBAL_SERVER_API_KEY"),
			InstanceID:        os.Getenv("INSTANCE_ID"),
			ServerPublicKey:   os.Getenv("SERVER_PUBLIC_KEY"),
			ServerPrivateKey:  os.Getenv("SERVER_PRIVATE_KEY"),
			GlobalRegisterURL: os.Getenv("GLOBAL_SERVER_REGISTER_URL"),
		},
	}, nil
}

// getEnv gets environment variable with default value
func getEnv(key, defaultValue string) string {
	if value := os.Getenv(key); value != "" {
		return value
	}
	return defaultValue
}


--- File: /internal/database/database.go ---

package database

import (
	"fmt"
	"log"
	"time"

	"github.com/dmytrosurovtsev/eckwmsgo/internal/config"
	embeddedpostgres "github.com/fergusstrange/embedded-postgres"
	"gorm.io/driver/postgres"
	"gorm.io/gorm"
	"gorm.io/gorm/logger"
)

// DB wraps gorm.DB and includes a reference to an embedded process if active
type DB struct {
	*gorm.DB
	embedded *embeddedpostgres.EmbeddedPostgres
}

// Connect establishes a connection to a PostgreSQL database (external or embedded)
func Connect(cfg config.DatabaseConfig) (*DB, error) {
	var embedded *embeddedpostgres.EmbeddedPostgres

	// Logic for Embedded Mode: Localhost and No Password
	if cfg.Host == "localhost" && cfg.Password == "" {
		log.Println("üì¶ Mode: [Embedded PostgreSQL] - Initializing internal database...")

		// Setup embedded configuration
		embeddedCfg := embeddedpostgres.DefaultConfig().
			DataPath("./db_data"). // Persistent data folder in the app directory
			Port(5433).            // Use custom port for embedded mode
			Database(cfg.Database).
			Username(cfg.Username)

		embedded = embeddedpostgres.NewDatabase(embeddedCfg)

		if err := embedded.Start(); err != nil {
			return nil, fmt.Errorf("failed to start embedded database: %w", err)
		}

		// Update connection parameters to point to the embedded instance
		cfg.Port = "5433"
		log.Println("‚úÖ Embedded PostgreSQL process started on port 5433")
	} else {
		log.Printf("üåê Mode: [External PostgreSQL] - Connecting to %s:%s\n", cfg.Host, cfg.Port)
	}

	dsn := fmt.Sprintf(
		"host=%s port=%s user=%s password=%s dbname=%s sslmode=disable",
		cfg.Host,
		cfg.Port,
		cfg.Username,
		cfg.Password,
		cfg.Database,
	)

	// Configure GORM
	logLevel := logger.Info
	if cfg.Alter {
		logLevel = logger.Silent
	}

	db, err := gorm.Open(postgres.Open(dsn), &gorm.Config{
		Logger: logger.Default.LogMode(logLevel),
		NowFunc: func() time.Time {
			return time.Now().UTC()
		},
	})
	if err != nil {
		// Clean up embedded process if GORM connection fails
		if embedded != nil {
			_ = embedded.Stop()
		}
		return nil, fmt.Errorf("failed to connect to database: %w", err)
	}

	sqlDB, err := db.DB()
	if err == nil {
		sqlDB.SetMaxIdleConns(10)
		sqlDB.SetMaxOpenConns(100)
		sqlDB.SetConnMaxLifetime(time.Hour)
	}

	log.Println("‚úÖ Database connection established")

	return &DB{
		DB:       db,
		embedded: embedded,
	}, nil
}

// Close ensures the database connection and embedded process are shut down
func (db *DB) Close() error {
	if db.embedded != nil {
		log.Println("üõë Stopping Embedded PostgreSQL process...")
		_ = db.embedded.Stop()
	}

	sqlDB, err := db.DB.DB()
	if err != nil {
		return err
	}
	return sqlDB.Close()
}

// AutoMigrate triggers GORM schema synchronization
func (db *DB) AutoMigrate(models ...interface{}) error {
	return db.DB.AutoMigrate(models...)
}


--- File: /internal/handlers/auth.go ---

package handlers

import (
	"encoding/json"
	"net/http"
	"time"

	"github.com/dmytrosurovtsev/eckwmsgo/internal/config"
	"github.com/dmytrosurovtsev/eckwmsgo/internal/models"
	"github.com/dmytrosurovtsev/eckwmsgo/internal/utils"
)

// LoginRequest represents a login request
type LoginRequest struct {
	Email    string `json:"email"`
	Password string `json:"password"`
}

// RegisterRequest represents a registration request
type RegisterRequest struct {
	Username string `json:"username"`
	Password string `json:"password"`
	Email    string `json:"email"`
	Name     string `json:"name"`
	Company  string `json:"company"`
}

// login handles user login
func (r *Router) login(w http.ResponseWriter, req *http.Request) {
	var loginReq LoginRequest
	if err := json.NewDecoder(req.Body).Decode(&loginReq); err != nil {
		respondError(w, http.StatusBadRequest, "Invalid request payload")
		return
	}

	// 1. Find User
	var user models.UserAuth
	if err := r.db.Where("email = ?", loginReq.Email).First(&user).Error; err != nil {
		respondError(w, http.StatusUnauthorized, "Invalid credentials")
		return
	}

	// 2. Check Password
	if !utils.CheckPasswordHash(loginReq.Password, user.Password) {
		respondError(w, http.StatusUnauthorized, "Invalid credentials")
		return
	}

	// 3. Update Last Login
	now := time.Now()
	user.LastLogin = &now
	r.db.Save(&user)

	// 4. Generate Tokens
	cfg, _ := config.Load()
	accessToken, refreshToken, err := utils.GenerateTokens(&user, cfg)
	if err != nil {
		respondError(w, http.StatusInternalServerError, "Failed to generate tokens")
		return
	}

	// 5. Respond matching Node.js structure
	response := map[string]interface{}{
		"tokens": map[string]string{
			"accessToken":  accessToken,
			"refreshToken": refreshToken,
		},
		"user": user,
	}

	respondJSON(w, http.StatusOK, response)
}

// register handles user registration
func (r *Router) register(w http.ResponseWriter, req *http.Request) {
	var regReq RegisterRequest
	if err := json.NewDecoder(req.Body).Decode(&regReq); err != nil {
		respondError(w, http.StatusBadRequest, "Invalid request payload")
		return
	}

	// 1. Hash Password
	hashedPassword, err := utils.HashPassword(regReq.Password)
	if err != nil {
		respondError(w, http.StatusInternalServerError, "Failed to hash password")
		return
	}

	// 2. Create User
	user := models.UserAuth{
		Username: regReq.Username,
		Email:    regReq.Email,
		Password: hashedPassword,
		Name:     regReq.Name,
		Company:  regReq.Company,
		Role:     "user",
		UserType: "individual",
	}

	if regReq.Company != "" {
		user.UserType = "company"
	}

	if err := r.db.Create(&user).Error; err != nil {
		respondError(w, http.StatusBadRequest, "Failed to create user (email or username might exist)")
		return
	}

	// 3. Generate Tokens for immediate login
	cfg, _ := config.Load()
	accessToken, refreshToken, err := utils.GenerateTokens(&user, cfg)
	if err != nil {
		respondError(w, http.StatusInternalServerError, "User created but failed to generate tokens")
		return
	}

	respondJSON(w, http.StatusCreated, map[string]interface{}{
		"message": "User registered successfully",
		"tokens": map[string]string{
			"accessToken":  accessToken,
			"refreshToken": refreshToken,
		},
		"user": user,
	})
}

// logout handles user logout
func (r *Router) logout(w http.ResponseWriter, req *http.Request) {
	// Client-side mostly, but we can handle cookie clearing here if needed
	respondJSON(w, http.StatusOK, map[string]string{"message": "Logged out successfully"})
}


--- File: /internal/handlers/rma.go ---

package handlers

import (
	"encoding/json"
	"net/http"
	"strconv"

	"github.com/dmytrosurovtsev/eckwmsgo/internal/models"
	"github.com/gorilla/mux"
)

// listRMAs returns all RMA requests
func (r *Router) listRMAs(w http.ResponseWriter, req *http.Request) {
	var rmas []models.RmaRequest
	if err := r.db.Find(&rmas).Error; err != nil {
		respondError(w, http.StatusInternalServerError, "Failed to fetch RMA requests")
		return
	}

	respondJSON(w, http.StatusOK, rmas)
}

// getRMA returns a single RMA request by ID
func (r *Router) getRMA(w http.ResponseWriter, req *http.Request) {
	vars := mux.Vars(req)
	id, err := strconv.ParseUint(vars["id"], 10, 32)
	if err != nil {
		respondError(w, http.StatusBadRequest, "Invalid RMA ID")
		return
	}

	var rma models.RmaRequest
	if err := r.db.First(&rma, id).Error; err != nil {
		respondError(w, http.StatusNotFound, "RMA request not found")
		return
	}

	respondJSON(w, http.StatusOK, rma)
}

// createRMA creates a new RMA request
func (r *Router) createRMA(w http.ResponseWriter, req *http.Request) {
	var rma models.RmaRequest
	if err := json.NewDecoder(req.Body).Decode(&rma); err != nil {
		respondError(w, http.StatusBadRequest, "Invalid request payload")
		return
	}

	if err := r.db.Create(&rma).Error; err != nil {
		respondError(w, http.StatusInternalServerError, "Failed to create RMA request")
		return
	}

	respondJSON(w, http.StatusCreated, rma)
}

// updateRMA updates an existing RMA request
func (r *Router) updateRMA(w http.ResponseWriter, req *http.Request) {
	vars := mux.Vars(req)
	id, err := strconv.ParseUint(vars["id"], 10, 32)
	if err != nil {
		respondError(w, http.StatusBadRequest, "Invalid RMA ID")
		return
	}

	var rma models.RmaRequest
	if err := r.db.First(&rma, id).Error; err != nil {
		respondError(w, http.StatusNotFound, "RMA request not found")
		return
	}

	if err := json.NewDecoder(req.Body).Decode(&rma); err != nil {
		respondError(w, http.StatusBadRequest, "Invalid request payload")
		return
	}

	if err := r.db.Save(&rma).Error; err != nil {
		respondError(w, http.StatusInternalServerError, "Failed to update RMA request")
		return
	}

	respondJSON(w, http.StatusOK, rma)
}

// deleteRMA deletes an RMA request
func (r *Router) deleteRMA(w http.ResponseWriter, req *http.Request) {
	vars := mux.Vars(req)
	id, err := strconv.ParseUint(vars["id"], 10, 32)
	if err != nil {
		respondError(w, http.StatusBadRequest, "Invalid RMA ID")
		return
	}

	if err := r.db.Delete(&models.RmaRequest{}, id).Error; err != nil {
		respondError(w, http.StatusInternalServerError, "Failed to delete RMA request")
		return
	}

	respondJSON(w, http.StatusOK, map[string]string{
		"message": "RMA request deleted successfully",
	})
}


--- File: /internal/handlers/router.go ---

package handlers

import (
	"encoding/json"
	"net/http"
	"os"
	"strings"

	"github.com/dmytrosurovtsev/eckwmsgo/internal/database"
	"github.com/dmytrosurovtsev/eckwmsgo/internal/middleware"
	"github.com/dmytrosurovtsev/eckwmsgo/internal/websocket"
	"github.com/dmytrosurovtsev/eckwmsgo/web"
	"github.com/gorilla/mux"
)

// Router wraps the mux router and database
type Router struct {
	*mux.Router
	db  *database.DB
	hub *websocket.Hub
}

// NewRouter creates a new HTTP router with all routes
func NewRouter(db *database.DB) *Router {
	// Initialize WebSocket Hub
	hub := websocket.NewHub()
	go hub.Run()

	r := &Router{
		Router: mux.NewRouter(),
		db:     db,
		hub:    hub,
	}

	// Health check endpoint
	r.HandleFunc("/health", r.healthCheck).Methods("GET")

	// API routes
	api := r.PathPrefix("/api").Subrouter()
	api.Use(middleware.AuthMiddleware)
	api.HandleFunc("/status", r.getStatus).Methods("GET")

	// Auth routes (Public)
	auth := r.PathPrefix("/auth").Subrouter()
	auth.HandleFunc("/login", r.login).Methods("POST")
	auth.HandleFunc("/register", r.register).Methods("POST")
	auth.HandleFunc("/logout", r.logout).Methods("POST")

	// RMA routes (protected)
	rma := r.PathPrefix("/rma").Subrouter()
	rma.Use(middleware.AuthMiddleware)
	rma.HandleFunc("", r.listRMAs).Methods("GET")
	rma.HandleFunc("", r.createRMA).Methods("POST")
	rma.HandleFunc("/{id}", r.getRMA).Methods("GET")
	rma.HandleFunc("/{id}", r.updateRMA).Methods("PUT")
	rma.HandleFunc("/{id}", r.deleteRMA).Methods("DELETE")

	// Warehouse routes (protected)
	warehouse := r.PathPrefix("/api/warehouse").Subrouter()
	warehouse.Use(middleware.AuthMiddleware)
	warehouse.HandleFunc("", r.listWarehouses).Methods("GET")
	warehouse.HandleFunc("", r.createWarehouse).Methods("POST")
	warehouse.HandleFunc("/{id}", r.getWarehouse).Methods("GET")

	// Item routes (protected)
	items := r.PathPrefix("/api/items").Subrouter()
	items.Use(middleware.AuthMiddleware)
	items.HandleFunc("", r.listItems).Methods("GET")
	items.HandleFunc("", r.createItem).Methods("POST")
	items.HandleFunc("/{id}", r.getItem).Methods("GET")

	// Setup & Device routes (protected)
	setup := r.PathPrefix("/api/internal").Subrouter()
	setup.Use(middleware.AuthMiddleware)
	setup.HandleFunc("/pairing-qr", r.generatePairingQR).Methods("GET")

	// Public device registration (device calls this initially)
	r.HandleFunc("/api/internal/register-device", r.registerDevice).Methods("POST")

	// WebSocket endpoint
	r.HandleFunc("/ws", func(w http.ResponseWriter, req *http.Request) {
		websocket.ServeWs(hub, w, req)
	})

	// --- Static Files (Svelte Frontend) ---
	// Get filesystem (embedded or disk)
	assets, err := web.GetFileSystem()
	if err != nil {
		// Fallback if something is wrong with embed
		publicDir := os.Getenv("FRONTEND_DIR")
		if publicDir == "" {
			publicDir = "web/build" // Default for SvelteKit
		}
		assets = os.DirFS(publicDir)
	}

	// SPA Handler: Serve index.html for unknown routes (so Svelte router works)
	spaHandler := http.FileServer(http.FS(assets))

	r.PathPrefix("/").HandlerFunc(func(w http.ResponseWriter, req *http.Request) {
		// If path looks like an API call or file extension, serve normally
		path := req.URL.Path
		if strings.HasPrefix(path, "/api") || strings.HasPrefix(path, "/auth") ||
			strings.HasPrefix(path, "/ws") || strings.HasPrefix(path, "/health") ||
			strings.HasPrefix(path, "/rma") || strings.Contains(path, ".") {
			spaHandler.ServeHTTP(w, req)
			return
		}
		// Otherwise serve index.html (SPA)
		req.URL.Path = "/"
		spaHandler.ServeHTTP(w, req)
	})

	return r
}

// healthCheck returns the health status of the API
func (r *Router) healthCheck(w http.ResponseWriter, req *http.Request) {
	respondJSON(w, http.StatusOK, map[string]string{
		"status": "ok",
		"server": "local",
	})
}

// getStatus returns the current status
func (r *Router) getStatus(w http.ResponseWriter, req *http.Request) {
	respondJSON(w, http.StatusOK, map[string]string{
		"status": "running",
		"version": "1.0.0",
	})
}

// respondJSON sends a JSON response
func respondJSON(w http.ResponseWriter, status int, data interface{}) {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(status)
	json.NewEncoder(w).Encode(data)
}

// respondError sends an error response
func respondError(w http.ResponseWriter, status int, message string) {
	respondJSON(w, status, map[string]string{
		"error": message,
	})
}


--- File: /internal/handlers/setup.go ---

package handlers

import (
	"crypto/ed25519"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"net/http"
	"os"
	"strings"

	"github.com/dmytrosurovtsev/eckwmsgo/internal/models"
	"github.com/skip2/go-qrcode"
)

// generatePairingQR creates the QR code for device pairing
func (r *Router) generatePairingQR(w http.ResponseWriter, req *http.Request) {
	instanceID := os.Getenv("INSTANCE_ID")
	pubKey := os.Getenv("SERVER_PUBLIC_KEY")
	serverURL := os.Getenv("GLOBAL_SERVER_URL")

	if instanceID == "" || pubKey == "" {
		respondError(w, http.StatusInternalServerError, "Server not configured for pairing")
		return
	}

	if serverURL == "" {
		serverURL = "http://localhost:3001"
	}

	// Compact UUID: Remove dashes and uppercase
	compactUUID := strings.ToUpper(strings.ReplaceAll(instanceID, "-", ""))

	// Decode public key from base64 and convert to hex uppercase
	pubKeyBytes, err := base64.StdEncoding.DecodeString(pubKey)
	if err != nil {
		respondError(w, http.StatusInternalServerError, "Invalid public key format")
		return
	}
	pubKeyHex := fmt.Sprintf("%x", pubKeyBytes)

	// Protocol: ECK$1$COMPACTUUID$PUBKEY_HEX$URL
	qrString := "ECK$1$" + compactUUID + "$" + pubKeyHex + "$" + strings.ToUpper(serverURL)

	png, err := qrcode.Encode(qrString, qrcode.Low, 256)
	if err != nil {
		respondError(w, http.StatusInternalServerError, "Failed to generate QR")
		return
	}

	w.Header().Set("Content-Type", "image/png")
	w.Write(png)
}

// DeviceRegisterRequest represents a device registration request
type DeviceRegisterRequest struct {
	DeviceID        string `json:"deviceId"`
	DeviceName      string `json:"deviceName"`
	DevicePublicKey string `json:"devicePublicKey"` // Base64
	Signature       string `json:"signature"`       // Base64
}

// registerDevice handles the cryptographic pairing handshake
func (r *Router) registerDevice(w http.ResponseWriter, req *http.Request) {
	var body DeviceRegisterRequest
	if err := json.NewDecoder(req.Body).Decode(&body); err != nil {
		respondError(w, http.StatusBadRequest, "Invalid request")
		return
	}

	// Validate required fields
	if body.DeviceID == "" || body.DevicePublicKey == "" || body.Signature == "" {
		respondError(w, http.StatusBadRequest, "Missing required fields")
		return
	}

	// 1. Verify Signature
	// Message format: {"deviceId":"...","devicePublicKey":"..."}
	msgStr := fmt.Sprintf("{\"deviceId\":\"%s\",\"devicePublicKey\":\"%s\"}", body.DeviceID, body.DevicePublicKey)
	msgBytes := []byte(msgStr)

	sigBytes, err := base64.StdEncoding.DecodeString(body.Signature)
	if err != nil {
		respondError(w, http.StatusBadRequest, "Invalid signature format")
		return
	}

	pubKeyBytes, err := base64.StdEncoding.DecodeString(body.DevicePublicKey)
	if err != nil {
		respondError(w, http.StatusBadRequest, "Invalid public key format")
		return
	}

	if len(pubKeyBytes) != ed25519.PublicKeySize {
		respondError(w, http.StatusBadRequest, "Invalid public key length")
		return
	}

	if len(sigBytes) != ed25519.SignatureSize {
		respondError(w, http.StatusBadRequest, "Invalid signature length")
		return
	}

	if !ed25519.Verify(pubKeyBytes, msgBytes, sigBytes) {
		respondError(w, http.StatusForbidden, "Invalid signature")
		return
	}

	// 2. Register or Update Device
	var device models.RegisteredDevice
	result := r.db.Where("device_id = ?", body.DeviceID).First(&device)

	if result.Error == nil {
		// Update existing
		device.PublicKey = body.DevicePublicKey
		device.IsActive = true
		if body.DeviceName != "" {
			device.DeviceName = body.DeviceName
		}
		r.db.Save(&device)
	} else {
		// Create new
		device = models.RegisteredDevice{
			DeviceID:   body.DeviceID,
			PublicKey:  body.DevicePublicKey,
			DeviceName: body.DeviceName,
			IsActive:   true,
			Status:     "pending",
		}
		r.db.Create(&device)
	}

	respondJSON(w, http.StatusOK, map[string]string{"status": "registered"})
}


--- File: /internal/handlers/warehouse.go ---

package handlers

import (
	"encoding/json"
	"net/http"
	"strconv"

	"github.com/dmytrosurovtsev/eckwmsgo/internal/models"
	"github.com/gorilla/mux"
)

// listWarehouses returns all warehouses
func (r *Router) listWarehouses(w http.ResponseWriter, req *http.Request) {
	var warehouses []models.Warehouse
	if err := r.db.Preload("Racks").Find(&warehouses).Error; err != nil {
		respondError(w, http.StatusInternalServerError, "Failed to fetch warehouses")
		return
	}

	respondJSON(w, http.StatusOK, warehouses)
}

// getWarehouse returns a single warehouse by ID
func (r *Router) getWarehouse(w http.ResponseWriter, req *http.Request) {
	vars := mux.Vars(req)
	id, err := strconv.ParseUint(vars["id"], 10, 32)
	if err != nil {
		respondError(w, http.StatusBadRequest, "Invalid warehouse ID")
		return
	}

	var warehouse models.Warehouse
	if err := r.db.Preload("Racks.Places").First(&warehouse, id).Error; err != nil {
		respondError(w, http.StatusNotFound, "Warehouse not found")
		return
	}

	respondJSON(w, http.StatusOK, warehouse)
}

// createWarehouse creates a new warehouse
func (r *Router) createWarehouse(w http.ResponseWriter, req *http.Request) {
	var warehouse models.Warehouse
	if err := json.NewDecoder(req.Body).Decode(&warehouse); err != nil {
		respondError(w, http.StatusBadRequest, "Invalid request payload")
		return
	}

	if err := r.db.Create(&warehouse).Error; err != nil {
		respondError(w, http.StatusInternalServerError, "Failed to create warehouse")
		return
	}

	respondJSON(w, http.StatusCreated, warehouse)
}

// listItems returns all items
func (r *Router) listItems(w http.ResponseWriter, req *http.Request) {
	var items []models.Item
	if err := r.db.Preload("Place").Preload("Box").Find(&items).Error; err != nil {
		respondError(w, http.StatusInternalServerError, "Failed to fetch items")
		return
	}

	respondJSON(w, http.StatusOK, items)
}

// getItem returns a single item by ID
func (r *Router) getItem(w http.ResponseWriter, req *http.Request) {
	vars := mux.Vars(req)
	id, err := strconv.ParseUint(vars["id"], 10, 32)
	if err != nil {
		respondError(w, http.StatusBadRequest, "Invalid item ID")
		return
	}

	var item models.Item
	if err := r.db.Preload("Place").Preload("Box").First(&item, id).Error; err != nil {
		respondError(w, http.StatusNotFound, "Item not found")
		return
	}

	respondJSON(w, http.StatusOK, item)
}

// createItem creates a new item
func (r *Router) createItem(w http.ResponseWriter, req *http.Request) {
	var item models.Item
	if err := json.NewDecoder(req.Body).Decode(&item); err != nil {
		respondError(w, http.StatusBadRequest, "Invalid request payload")
		return
	}

	if err := r.db.Create(&item).Error; err != nil {
		respondError(w, http.StatusInternalServerError, "Failed to create item")
		return
	}

	respondJSON(w, http.StatusCreated, item)
}


--- File: /internal/middleware/auth.go ---

package middleware

import (
	"context"
	"net/http"
	"strings"

	"github.com/dmytrosurovtsev/eckwmsgo/internal/config"
	"github.com/dmytrosurovtsev/eckwmsgo/internal/utils"
)

type contextKey string

const UserContextKey contextKey = "user"

// AuthMiddleware verifies JWT tokens
func AuthMiddleware(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		authHeader := r.Header.Get("Authorization")
		if authHeader == "" {
			http.Error(w, "Authorization header required", http.StatusUnauthorized)
			return
		}

		// Bearer token
		parts := strings.Split(authHeader, " ")
		if len(parts) != 2 || parts[0] != "Bearer" {
			http.Error(w, "Invalid authorization header format", http.StatusUnauthorized)
			return
		}

		tokenString := parts[1]
		cfg, _ := config.Load()

		claims, err := utils.ValidateToken(tokenString, cfg.JWTSecret)
		if err != nil {
			http.Error(w, "Invalid or expired token", http.StatusUnauthorized)
			return
		}

		// Add claims to context
		ctx := context.WithValue(r.Context(), UserContextKey, claims)
		next.ServeHTTP(w, r.WithContext(ctx))
	})
}


--- File: /internal/models/device.go ---

package models

import (
	"time"

	"gorm.io/gorm"
)

// RegisteredDevice represents a paired mobile device
type RegisteredDevice struct {
	DeviceID   string         `gorm:"primaryKey" json:"deviceId"`
	InstanceID *string        `json:"instance_id,omitempty"`
	IsActive   bool           `gorm:"default:true" json:"is_active"`
	Status     string         `gorm:"default:'pending'" json:"status"` // active, pending, blocked
	PublicKey  string         `gorm:"not null" json:"publicKey"`       // Base64
	DeviceName string         `json:"deviceName"`
	RoleID     *uint          `json:"role_id,omitempty"`
	CreatedAt  time.Time      `json:"created_at"`
	UpdatedAt  time.Time      `json:"updated_at"`
	DeletedAt  gorm.DeletedAt `gorm:"index" json:"-"`
}

// TableName specifies the table name for RegisteredDevice
func (RegisteredDevice) TableName() string {
	return "registered_devices"
}


--- File: /internal/models/item.go ---

package models

import (
	"time"

	"gorm.io/gorm"
)

// Item represents an item in the warehouse
type Item struct {
	ID          uint           `gorm:"primaryKey" json:"id"`
	SKU         string         `gorm:"unique;not null" json:"sku"`
	Name        string         `gorm:"not null" json:"name"`
	Description string         `json:"description"`
	Category    string         `json:"category"`
	Barcode     string         `gorm:"unique" json:"barcode"`
	PlaceID     *uint          `gorm:"index" json:"place_id,omitempty"`
	BoxID       *uint          `gorm:"index" json:"box_id,omitempty"`
	Quantity    int            `gorm:"default:0" json:"quantity"`
	MinStock    int            `gorm:"default:0" json:"min_stock"`
	MaxStock    int            `json:"max_stock"`
	UnitPrice   float64        `json:"unit_price"`
	IsActive    bool           `gorm:"default:true" json:"is_active"`
	CreatedAt   time.Time      `json:"created_at"`
	UpdatedAt   time.Time      `json:"updated_at"`
	DeletedAt   gorm.DeletedAt `gorm:"index" json:"-"`

	// Relations
	Place       *Place         `gorm:"foreignKey:PlaceID" json:"place,omitempty"`
	Box         *Box           `gorm:"foreignKey:BoxID" json:"box,omitempty"`
}

// TableName specifies the table name for Item model
func (Item) TableName() string {
	return "items"
}

// Box represents a container for items
type Box struct {
	ID          uint           `gorm:"primaryKey" json:"id"`
	BoxNumber   string         `gorm:"unique;not null" json:"box_number"`
	Name        string         `json:"name"`
	Barcode     string         `gorm:"unique" json:"barcode"`
	PlaceID     *uint          `gorm:"index" json:"place_id,omitempty"`
	Capacity    int            `json:"capacity"`
	IsActive    bool           `gorm:"default:true" json:"is_active"`
	CreatedAt   time.Time      `json:"created_at"`
	UpdatedAt   time.Time      `json:"updated_at"`
	DeletedAt   gorm.DeletedAt `gorm:"index" json:"-"`

	// Relations
	Place       *Place         `gorm:"foreignKey:PlaceID" json:"place,omitempty"`
	Items       []Item         `gorm:"foreignKey:BoxID" json:"items,omitempty"`
}

// TableName specifies the table name for Box model
func (Box) TableName() string {
	return "boxes"
}

// ProductAlias represents an alias for a product
type ProductAlias struct {
	ID          uint           `gorm:"primaryKey" json:"id"`
	ProductSKU  string         `gorm:"not null;index" json:"product_sku"`
	Alias       string         `gorm:"not null" json:"alias"`
	AliasType   string         `json:"alias_type"`
	CreatedAt   time.Time      `json:"created_at"`
	UpdatedAt   time.Time      `json:"updated_at"`
	DeletedAt   gorm.DeletedAt `gorm:"index" json:"-"`
}

// TableName specifies the table name for ProductAlias model
func (ProductAlias) TableName() string {
	return "product_aliases"
}


--- File: /internal/models/rma.go ---

package models

import (
	"time"

	"gorm.io/datatypes"
	"gorm.io/gorm"
)

// RmaRequest represents a return merchandise authorization request
type RmaRequest struct {
	ID                uint           `gorm:"primaryKey" json:"id"`
	RMANumber         string         `gorm:"unique;not null" json:"rma_number"`
	CustomerName      string         `gorm:"not null" json:"customer_name"`
	CustomerEmail     string         `json:"customer_email"`
	CustomerPhone     string         `json:"customer_phone"`
	ProductSKU        string         `gorm:"not null;index" json:"product_sku"`
	ProductName       string         `json:"product_name"`
	SerialNumber      string         `json:"serial_number"`
	PurchaseDate      *time.Time     `json:"purchase_date,omitempty"`
	IssueDescription  string         `gorm:"type:text" json:"issue_description"`
	Status            string         `gorm:"default:'pending'" json:"status"`
	Priority          string         `gorm:"default:'normal'" json:"priority"`
	AssignedTo        *uint          `gorm:"index" json:"assigned_to,omitempty"`
	Resolution        string         `gorm:"type:text" json:"resolution"`
	Notes             string         `gorm:"type:text" json:"notes"`
	Metadata          datatypes.JSON `json:"metadata"`
	CreatedAt         time.Time      `json:"created_at"`
	UpdatedAt         time.Time      `json:"updated_at"`
	ResolvedAt        *time.Time     `json:"resolved_at,omitempty"`
	DeletedAt         gorm.DeletedAt `gorm:"index" json:"-"`

	// Relations
	AssignedUser      *UserAuth      `gorm:"foreignKey:AssignedTo" json:"assigned_user,omitempty"`
}

// TableName specifies the table name for RmaRequest model
func (RmaRequest) TableName() string {
	return "rma_requests"
}

// RepairOrder represents a repair order for an item
type RepairOrder struct {
	ID                uint           `gorm:"primaryKey" json:"id"`
	OrderNumber       string         `gorm:"unique;not null" json:"order_number"`
	RMARequestID      *uint          `gorm:"index" json:"rma_request_id,omitempty"`
	ItemID            uint           `gorm:"not null;index" json:"item_id"`
	TechnicianID      *uint          `gorm:"index" json:"technician_id,omitempty"`
	Status            string         `gorm:"default:'pending'" json:"status"`
	DiagnosisNotes    string         `gorm:"type:text" json:"diagnosis_notes"`
	RepairNotes       string         `gorm:"type:text" json:"repair_notes"`
	PartsUsed         datatypes.JSON `json:"parts_used"`
	LaborHours        float64        `json:"labor_hours"`
	TotalCost         float64        `json:"total_cost"`
	StartedAt         *time.Time     `json:"started_at,omitempty"`
	CompletedAt       *time.Time     `json:"completed_at,omitempty"`
	CreatedAt         time.Time      `json:"created_at"`
	UpdatedAt         time.Time      `json:"updated_at"`
	DeletedAt         gorm.DeletedAt `gorm:"index" json:"-"`

	// Relations
	RMARequest        *RmaRequest    `gorm:"foreignKey:RMARequestID" json:"rma_request,omitempty"`
	Item              Item           `gorm:"foreignKey:ItemID" json:"item,omitempty"`
	Technician        *UserAuth      `gorm:"foreignKey:TechnicianID" json:"technician,omitempty"`
}

// TableName specifies the table name for RepairOrder model
func (RepairOrder) TableName() string {
	return "repair_orders"
}


--- File: /internal/models/user.go ---

package models

import (
	"time"

	"gorm.io/gorm"
)

// UserAuth represents a user in the system
type UserAuth struct {
	ID                  string         `gorm:"primaryKey;type:uuid;default:gen_random_uuid()" json:"id"`
	Username            string         `gorm:"unique;not null" json:"username"`
	Password            string         `gorm:"not null" json:"-"` // Never send password in JSON
	Email               string         `gorm:"unique;not null" json:"email"`
	Name                string         `json:"name,omitempty"`
	Role                string         `gorm:"default:'user'" json:"role"`
	UserType            string         `gorm:"default:'individual'" json:"user_type"`
	Company             string         `json:"company,omitempty"`
	GoogleID            *string        `json:"google_id,omitempty"`
	IsActive            bool           `gorm:"default:true" json:"is_active"`
	LastLogin           *time.Time     `json:"last_login,omitempty"`
	FailedLoginAttempts int            `gorm:"default:0" json:"-"`
	PreferredLanguage   string         `gorm:"default:'en'" json:"preferred_language"`
	CreatedAt           time.Time      `json:"created_at"`
	UpdatedAt           time.Time      `json:"updated_at"`
	DeletedAt           gorm.DeletedAt `gorm:"index" json:"-"`
}

// TableName specifies the table name for UserAuth model
func (UserAuth) TableName() string {
	return "user_auths"
}


--- File: /internal/models/warehouse.go ---

package models

import (
	"time"

	"gorm.io/gorm"
)

// Warehouse represents a warehouse in the system
type Warehouse struct {
	ID          uint           `gorm:"primaryKey" json:"id"`
	Name        string         `gorm:"not null;unique" json:"name"`
	Location    string         `json:"location"`
	Description string         `json:"description"`
	IsActive    bool           `gorm:"default:true" json:"is_active"`
	CreatedAt   time.Time      `json:"created_at"`
	UpdatedAt   time.Time      `json:"updated_at"`
	DeletedAt   gorm.DeletedAt `gorm:"index" json:"-"`

	// Relations
	Racks       []WarehouseRack `gorm:"foreignKey:WarehouseID" json:"racks,omitempty"`
}

// TableName specifies the table name for Warehouse model
func (Warehouse) TableName() string {
	return "warehouses"
}

// WarehouseRack represents a rack in a warehouse
type WarehouseRack struct {
	ID          uint           `gorm:"primaryKey" json:"id"`
	WarehouseID uint           `gorm:"not null;index" json:"warehouse_id"`
	Name        string         `gorm:"not null" json:"name"`
	Section     string         `json:"section"`
	Level       int            `json:"level"`
	Position    int            `json:"position"`
	Capacity    int            `json:"capacity"`
	IsActive    bool           `gorm:"default:true" json:"is_active"`
	CreatedAt   time.Time      `json:"created_at"`
	UpdatedAt   time.Time      `json:"updated_at"`
	DeletedAt   gorm.DeletedAt `gorm:"index" json:"-"`

	// Relations
	Warehouse   Warehouse      `gorm:"foreignKey:WarehouseID" json:"warehouse,omitempty"`
	Places      []Place        `gorm:"foreignKey:RackID" json:"places,omitempty"`
}

// TableName specifies the table name for WarehouseRack model
func (WarehouseRack) TableName() string {
	return "warehouse_racks"
}

// Place represents a specific location in a rack
type Place struct {
	ID          uint           `gorm:"primaryKey" json:"id"`
	RackID      uint           `gorm:"not null;index" json:"rack_id"`
	Name        string         `gorm:"not null" json:"name"`
	Row         int            `json:"row"`
	Column      int            `json:"column"`
	Barcode     string         `gorm:"unique" json:"barcode"`
	IsOccupied  bool           `gorm:"default:false" json:"is_occupied"`
	CreatedAt   time.Time      `json:"created_at"`
	UpdatedAt   time.Time      `json:"updated_at"`
	DeletedAt   gorm.DeletedAt `gorm:"index" json:"-"`

	// Relations
	Rack        WarehouseRack  `gorm:"foreignKey:RackID" json:"rack,omitempty"`
}

// TableName specifies the table name for Place model
func (Place) TableName() string {
	return "places"
}


--- File: /internal/utils/auth.go ---

package utils

import (
	"errors"
	"time"

	"github.com/dmytrosurovtsev/eckwmsgo/internal/config"
	"github.com/dmytrosurovtsev/eckwmsgo/internal/models"
	"github.com/golang-jwt/jwt/v5"
	"golang.org/x/crypto/bcrypt"
)

// HashPassword hashes a password using bcrypt
func HashPassword(password string) (string, error) {
	bytes, err := bcrypt.GenerateFromPassword([]byte(password), 10)
	return string(bytes), err
}

// CheckPasswordHash compares a password with a hash
func CheckPasswordHash(password, hash string) bool {
	err := bcrypt.CompareHashAndPassword([]byte(hash), []byte(password))
	return err == nil
}

// GenerateTokens generates Access and Refresh tokens
func GenerateTokens(user *models.UserAuth, cfg *config.Config) (string, string, error) {
	// Access Token Claims
	claims := jwt.MapClaims{
		"id":       user.ID,
		"email":    user.Email,
		"role":     user.Role,
		"userType": user.UserType,
		"exp":      time.Now().Add(time.Hour * 1).Unix(), // 1 hour expiration
	}

	token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
	accessToken, err := token.SignedString([]byte(cfg.JWTSecret))
	if err != nil {
		return "", "", err
	}

	// Refresh Token Claims
	refreshClaims := jwt.MapClaims{
		"id":  user.ID,
		"exp": time.Now().Add(time.Hour * 24 * 90).Unix(), // 90 days
	}
	refreshTokenObj := jwt.NewWithClaims(jwt.SigningMethodHS256, refreshClaims)
	refreshToken, err := refreshTokenObj.SignedString([]byte(cfg.JWTSecret))
	if err != nil {
		return "", "", err
	}

	return accessToken, refreshToken, nil
}

// ValidateToken parses and validates a token
func ValidateToken(tokenString string, secret string) (jwt.MapClaims, error) {
	token, err := jwt.Parse(tokenString, func(token *jwt.Token) (interface{}, error) {
		if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {
			return nil, errors.New("unexpected signing method")
		}
		return []byte(secret), nil
	})

	if err != nil {
		return nil, err
	}

	if claims, ok := token.Claims.(jwt.MapClaims); ok && token.Valid {
		return claims, nil
	}

	return nil, errors.New("invalid token")
}


--- File: /internal/utils/auth_test.go ---

package utils

import (
	"testing"

	"github.com/dmytrosurovtsev/eckwmsgo/internal/config"
	"github.com/dmytrosurovtsev/eckwmsgo/internal/models"
)

func TestPasswordHashing(t *testing.T) {
	password := "secret123"

	// Test Hashing
	hash, err := HashPassword(password)
	if err != nil {
		t.Fatalf("Failed to hash password: %v", err)
	}
	if hash == password {
		t.Error("Hash should not match plaintext password")
	}
	if len(hash) == 0 {
		t.Error("Hash should not be empty")
	}

	// Test Comparison (Success)
	if !CheckPasswordHash(password, hash) {
		t.Error("Password should match hash")
	}

	// Test Comparison (Failure)
	if CheckPasswordHash("wrongpassword", hash) {
		t.Error("Wrong password should not match hash")
	}
}

func TestJWT(t *testing.T) {
	// Setup Mock Config
	cfg := &config.Config{
		JWTSecret: "[REDACTED_GENERIC_SECRET]",
	}

	user := &models.UserAuth{
		ID:       "uuid-1234",
		Email:    "test@example.com",
		Role:     "admin",
		UserType: "company",
	}

	// Test Generation
	accessToken, refreshToken, err := GenerateTokens(user, cfg)
	if err != nil {
		t.Fatalf("Failed to generate tokens: %v", err)
	}
	if accessToken == "" || refreshToken == "" {
		t.Error("Tokens should not be empty")
	}

	// Test Validation (Success)
	claims, err := ValidateToken(accessToken, cfg.JWTSecret)
	if err != nil {
		t.Fatalf("Failed to validate token: %v", err)
	}

	if claims["id"] != user.ID {
		t.Errorf("Expected user ID %s, got %v", user.ID, claims["id"])
	}
	if claims["email"] != user.Email {
		t.Errorf("Expected email %s, got %v", user.Email, claims["email"])
	}

	// Test Validation (Failure - Wrong Key)
	_, err = ValidateToken(accessToken, "wrong-key")
	if err == nil {
		t.Error("Validation should fail with wrong key")
	}
}


--- File: /internal/websocket/client.go ---

package websocket

import (
	"encoding/json"
	"log"
	"net/http"
	"time"

	"github.com/gorilla/websocket"
)

const (
	// Time allowed to write a message to the peer.
	writeWait = 10 * time.Second

	// Time allowed to read the next pong message from the peer.
	pongWait = 60 * time.Second

	// Send pings to peer with this period. Must be less than pongWait.
	pingPeriod = (pongWait * 9) / 10

	// Maximum message size allowed from peer.
	maxMessageSize = 512 * 1024 // 512KB
)

var upgrader = websocket.Upgrader{
	ReadBufferSize:  1024,
	WriteBufferSize: 1024,
	// Allow all origins for mobile app access
	CheckOrigin: func(r *http.Request) bool { return true },
}

// Client is a middleman between the websocket connection and the hub.
type Client struct {
	hub *Hub

	// The websocket connection.
	conn *websocket.Conn

	// Buffered channel of outbound messages.
	send chan []byte

	// Device ID identified after handshake
	DeviceID string
}

// BaseMessage is the basic message structure for routing
type BaseMessage struct {
	Type     string `json:"type"`
	DeviceID string `json:"deviceId,omitempty"`
	MsgID    string `json:"msgId,omitempty"`
}

// readPump pumps messages from the websocket connection to the hub.
func (c *Client) readPump() {
	defer func() {
		c.hub.unregister <- c
		c.conn.Close()
	}()
	c.conn.SetReadLimit(maxMessageSize)
	c.conn.SetReadDeadline(time.Now().Add(pongWait))
	c.conn.SetPongHandler(func(string) error { c.conn.SetReadDeadline(time.Now().Add(pongWait)); return nil })

	for {
		_, message, err := c.conn.ReadMessage()
		if err != nil {
			if websocket.IsUnexpectedCloseError(err, websocket.CloseGoingAway, websocket.CloseAbnormalClosure) {
				log.Printf("WS error: %v", err)
			}
			break
		}

		// Handle basic protocol messages here
		var msg BaseMessage
		if err := json.Unmarshal(message, &msg); err == nil {
			// 1. DEVICE_IDENTIFY Handshake
			if msg.Type == "DEVICE_IDENTIFY" && msg.DeviceID != "" {
				c.DeviceID = msg.DeviceID
				c.hub.register <- c

				// Send ACK
				ack := map[string]string{
					"type":   "ACK",
					"msgId":  msg.MsgID,
					"status": "connected",
				}
				c.SendJSON(ack)
				continue
			}
		}

		// TODO: Pass other messages to ScanHandler/Business Logic
		log.Printf("WS Recv: %s", string(message))
	}
}

// writePump pumps messages from the hub to the websocket connection.
func (c *Client) writePump() {
	ticker := time.NewTicker(pingPeriod)
	defer func() {
		ticker.Stop()
		c.conn.Close()
	}()

	for {
		select {
		case message, ok := <-c.send:
			c.conn.SetWriteDeadline(time.Now().Add(writeWait))
			if !ok {
				// The hub closed the channel.
				c.conn.WriteMessage(websocket.CloseMessage, []byte{})
				return
			}

			w, err := c.conn.NextWriter(websocket.TextMessage)
			if err != nil {
				return
			}
			w.Write(message)

			if err := w.Close(); err != nil {
				return
			}
		case <-ticker.C:
			c.conn.SetWriteDeadline(time.Now().Add(writeWait))
			if err := c.conn.WriteMessage(websocket.PingMessage, nil); err != nil {
				return
			}
		}
	}
}

// SendJSON sends a JSON message to the client
func (c *Client) SendJSON(v interface{}) error {
	msg, err := json.Marshal(v)
	if err != nil {
		return err
	}
	c.send <- msg
	return nil
}

// ServeWs handles websocket requests from the peer.
func ServeWs(hub *Hub, w http.ResponseWriter, r *http.Request) {
	conn, err := upgrader.Upgrade(w, r, nil)
	if err != nil {
		log.Println(err)
		return
	}
	client := &Client{hub: hub, conn: conn, send: make(chan []byte, 256)}

	// Allow connection, registration happens via message later
	go client.writePump()
	go client.readPump()
}


--- File: /internal/websocket/hub.go ---

package websocket

import (
	"encoding/json"
	"log"
	"sync"
)

// Hub maintains the set of active clients and broadcasts messages
type Hub struct {
	// Registered clients map: DeviceID -> Client
	clients map[string]*Client

	// Register requests
	register chan *Client

	// Unregister requests
	unregister chan *Client

	// Mutex for thread-safe access to clients map
	mu sync.RWMutex
}

// NewHub creates a new Hub instance
func NewHub() *Hub {
	return &Hub{
		register:   make(chan *Client),
		unregister: make(chan *Client),
		clients:    make(map[string]*Client),
	}
}

// Run starts the hub's main loop
func (h *Hub) Run() {
	for {
		select {
		case client := <-h.register:
			h.mu.Lock()
			if client.DeviceID != "" {
				// If device connects again, close old connection
				if old, ok := h.clients[client.DeviceID]; ok {
					close(old.send)
					delete(h.clients, client.DeviceID)
				}
				h.clients[client.DeviceID] = client
				log.Printf("üì± Device connected: %s", client.DeviceID)
			}
			h.mu.Unlock()

		case client := <-h.unregister:
			h.mu.Lock()
			if client.DeviceID != "" {
				if _, ok := h.clients[client.DeviceID]; ok {
					delete(h.clients, client.DeviceID)
					close(client.send)
					log.Printf("üì¥ Device disconnected: %s", client.DeviceID)
				}
			}
			h.mu.Unlock()
		}
	}
}

// SendToDevice sends a message to a specific device
func (h *Hub) SendToDevice(deviceID string, message interface{}) bool {
	h.mu.RLock()
	client, ok := h.clients[deviceID]
	h.mu.RUnlock()

	if !ok {
		return false
	}

	jsonMsg, err := json.Marshal(message)
	if err != nil {
		log.Printf("Error marshaling message: %v", err)
		return false
	}

	select {
	case client.send <- jsonMsg:
		return true
	default:
		// Buffer full or client dead
		return false
	}
}


--- File: /web/efs.go ---

package web

import (
	"embed"
	"io/fs"
	"os"
)

//go:embed build/*
var distFS embed.FS

// GetFileSystem returns the static files to serve.
func GetFileSystem() (fs.FS, error) {
	// 1. Dev mode: Serve from disk
	if dir := os.Getenv("FRONTEND_DIR"); dir != "" {
		return os.DirFS(dir), nil
	}

	// 2. Production mode: Serve embedded files
	// SvelteKit outputs to "build" folder by default with adapter-static
	sub, err := fs.Sub(distFS, "build")
	if err != nil {
		return nil, err
	}
	return sub, nil
}


--- File: /web/go.mod ---

module github.com/dmytrosurovtsev/eckwmsgo/web

go 1.25.5


--- File: /web/package.json ---

{
  "name": "eckwms-web",
  "version": "0.0.1",
  "private": true,
  "type": "module",
  "scripts": {
    "dev": "vite dev",
    "build": "vite build",
    "preview": "vite preview"
  },
  "devDependencies": {
    "@sveltejs/adapter-static": "^3.0.0",
    "@sveltejs/kit": "^2.0.0",
    "@sveltejs/vite-plugin-svelte": "^5.0.0",
    "svelte": "^5.0.0",
    "vite": "^6.0.0"
  }
}


--- File: /web/src/app.html ---

<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<link rel="icon" href="%sveltekit.assets%/favicon.png" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		%sveltekit.head%
	</head>
	<body data-sveltekit-preload-data="hover">
		<div style="display: contents">%sveltekit.body%</div>
	</body>
</html>


--- File: /web/src/routes/+layout.js ---

// Disable SSR for SPA mode
export const ssr = false;
export const prerender = false;


--- File: /web/src/routes/+page.svelte ---

<script>
	let count = $state(0);

	function increment() {
		count += 1;
	}
</script>

<main>
	<h1>ECKWMS</h1>
	<p>SvelteKit SPA + Go Backend</p>

	<button onclick={increment}>
		Count is {count}
	</button>
</main>

<style>
	main {
		text-align: center;
		padding: 2rem;
		font-family: system-ui, sans-serif;
	}

	h1 {
		color: #646cff;
	}

	button {
		padding: 0.5rem 1rem;
		font-size: 1rem;
		cursor: pointer;
		background: #646cff;
		color: white;
		border: none;
		border-radius: 4px;
	}

	button:hover {
		background: #535bf2;
	}
</style>


--- File: /web/svelte.config.js ---

import adapter from '@sveltejs/adapter-static';

/** @type {import('@sveltejs/kit').Config} */
const config = {
	kit: {
		adapter: adapter({
			fallback: 'index.html',
			strict: false
		}),
		paths: {
			base: ''
		}
	}
};

export default config;


--- File: /web/vite.config.js ---

import { sveltekit } from '@sveltejs/kit/vite';
import { defineConfig } from 'vite';

export default defineConfig({
	plugins: [sveltekit()]
});


