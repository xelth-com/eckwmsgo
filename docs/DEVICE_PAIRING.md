# ECK-P1-ALPHA Device Pairing Protocol

## Overview

The ECK-P1-ALPHA protocol provides secure cryptographic pairing for Android PDA/scanner devices. It uses Ed25519 public-key cryptography to establish trust between the server and mobile devices without transmitting passwords over the network.

**Protocol Version:** 1 (P1-ALPHA)
**Cryptography:** Ed25519 (EdDSA signature scheme)
**Status:** Production-Ready

---

## Architecture

### Components

1. **Server Identity System** (`internal/utils/identity.go`)
   - Generates and persists Ed25519 keypair on first startup
   - Stores Instance ID (UUID) for server identification
   - Persistence: `.eck/server_identity.json` (excluded from git)

2. **Device Model** (`internal/models/device.go`)
   - `RegisteredDevice` table tracks all paired devices
   - Status workflow: `pending` → `active` or `blocked`
   - Public key storage for signature verification

3. **Pairing Endpoints** (`internal/handlers/setup.go`)
   - `GET /api/internal/pairing-qr` - QR code generation
   - `POST /api/internal/register-device` - Device handshake

4. **Admin Interface** (`web/src/routes/dashboard/devices/`)
   - Device list with status badges
   - Approve/Block controls
   - QR code viewer

5. **Access Control** (`internal/handlers/scan.go`)
   - Real-time device status validation
   - Prevents blocked devices from using valid JWTs

---

## Protocol Specification

### Phase 1: QR Code Generation

**Endpoint:** `GET /api/internal/pairing-qr`
**Authentication:** Required (JWT from admin user)

**QR Code Format:**
```
ECK$1$COMPACTUUID$PUBKEY_HEX$URL
```

**Components:**
- `ECK` - Protocol identifier
- `1` - Protocol version
- `COMPACTUUID` - Server Instance ID (uppercase, no dashes)
- `PUBKEY_HEX` - Server's Ed25519 public key (hex uppercase)
- `URL` - Server base URL (uppercase)

**Example:**
```
ECK$1$36563884FB24CF082BDF16EF6941AB2$981C7872C79CDDCC...
```

### Phase 2: Device Registration

**Endpoint:** `POST /api/internal/register-device`
**Authentication:** None (public endpoint, verified by signature)

**Request Payload:**
```json
{
  "deviceId": "550e8400-e29b-41d4-a716-446655440000",
  "deviceName": "Scanner-01",
  "devicePublicKey": "mBx4csec3fTMahaoK2tiNY8qTkcBRfiJEjID5JRi9HY=",
  "signature": "ZXlKaGJHY2lPaUpJVXpJMU5pSXNJblI1Y0NJNklrcFhWQ0o5..."
}
```

**Fields:**
- `deviceId` - UUID generated by device
- `deviceName` - Human-readable identifier
- `devicePublicKey` - Device's Ed25519 public key (Base64)
- `signature` - Ed25519 signature of message (Base64)

**Signature Message:**
```json
{"deviceId":"<UUID>","devicePublicKey":"<BASE64>"}
```

**Response (Pending):**
```json
{
  "success": true,
  "status": "pending",
  "token": "",
  "message": "Device handshake complete"
}
```

**Response (Active):**
```json
{
  "success": true,
  "status": "active",
  "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
  "message": "Device handshake complete"
}
```

**Response (Blocked):**
```json
{
  "success": true,
  "status": "blocked",
  "token": "",
  "message": "Device handshake complete"
}
```

### Phase 3: Admin Approval

**Endpoint:** `PUT /api/admin/devices/{deviceId}/status`
**Authentication:** Required (JWT from admin user)

**Request Payload:**
```json
{
  "status": "active"
}
```

**Valid Status Values:**
- `pending` - Awaiting admin review
- `active` - Authorized to access API
- `blocked` - Denied access

### Phase 4: Token Acquisition (Silent Re-registration)

The Android app periodically polls the `/register-device` endpoint. Once the admin approves the device, the server returns a JWT token in the response.

**Polling Strategy:**
1. Initial registration: Device receives `"pending"` status
2. App polls every 5 seconds for 60 seconds
3. When status changes to `"active"`, token is returned
4. App stores token and begins normal operation

### Phase 5: API Access

**All API Requests:**
```http
POST /api/scan
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
Content-Type: application/json

{
  "barcode": "i-12345",
  "deviceId": "550e8400-e29b-41d4-a716-446655440000",
  "msgId": "msg-001"
}
```

**Real-time Status Check:**
- Every request triggers database lookup
- Device must be in `"active"` status
- Blocked devices receive `403 Forbidden` immediately

---

## Security Model

### Cryptographic Foundation

**Ed25519 Key Properties:**
- Public key: 32 bytes (256 bits)
- Private key: 32 bytes (256 bits)
- Signature: 64 bytes (512 bits)
- Fast verification (~70,000 verifications/second)

**Threat Model:**
1. ✅ **Man-in-the-Middle:** QR code includes server's public key
2. ✅ **Replay Attacks:** Each device has unique keypair
3. ✅ **Authorization Bypass:** Real-time database lookup
4. ✅ **Token Theft:** Tokens tied to device ID, revocable
5. ✅ **Impersonation:** Signature verification required

### Attack Surface

**Protected:**
- Device registration (signature verification)
- API access (JWT + real-time status check)
- Admin interface (JWT authentication)

**Public:**
- QR code generation endpoint (requires admin auth)
- Device registration endpoint (public, but signature-verified)

### Revocation

**Immediate Revocation:**
1. Admin clicks "Block" button
2. Database status updated to `"blocked"`
3. Next API request fails (real-time check)
4. No grace period

**Token Expiration:**
- JWT tokens expire after configured duration (default: 24 hours)
- Even with valid token, blocked devices cannot access API
- Devices must re-register to obtain new token after expiration

---

## Database Schema

### RegisteredDevice Table

```sql
CREATE TABLE registered_devices (
    device_id VARCHAR PRIMARY KEY,
    name VARCHAR,
    public_key VARCHAR NOT NULL,
    status VARCHAR DEFAULT 'pending',
    last_seen_at TIMESTAMP,
    created_at TIMESTAMP,
    updated_at TIMESTAMP,
    deleted_at TIMESTAMP
);

CREATE INDEX idx_registered_devices_status ON registered_devices(status);
CREATE INDEX idx_registered_devices_deleted_at ON registered_devices(deleted_at);
```

**Status Values:**
- `pending` - Initial state, awaiting approval
- `active` - Authorized to work
- `blocked` - Explicitly denied

---

## Operational Workflows

### Pairing a New Device

1. **Admin Opens Dashboard**
   - Navigate to `/dashboard/devices`
   - Click "Show Pairing QR"

2. **Device Scans QR Code**
   - Android app decodes ECK protocol
   - Extracts server URL and public key
   - Generates own Ed25519 keypair

3. **Device Sends Registration**
   - Signs message with private key
   - Sends to `/api/internal/register-device`
   - Receives `"pending"` status

4. **Admin Reviews Device**
   - Device appears in table with pending badge
   - Admin verifies device name and ID
   - Clicks ✅ Approve button

5. **Device Acquires Token**
   - App polls registration endpoint
   - Receives `"active"` status + JWT token
   - Begins normal operation

### Blocking a Device

1. **Admin Opens Devices Page**
   - Navigate to `/dashboard/devices`
   - Locate device in table

2. **Click Block Button**
   - Status changes to `"blocked"`
   - Immediate effect (next API call fails)

3. **Device Response**
   - Next scan attempt: `403 Forbidden: "Device is blocked"`
   - App should display error to user
   - App should stop automatic polling

### Unblocking a Device

1. **Admin Changes Status to Active**
   - Click ✅ Approve button on blocked device
   - Status changes to `"active"`

2. **Device Resumes Operation**
   - Next poll receives token
   - Normal operation resumes

---

## Troubleshooting

### Device Shows "Pending" Indefinitely

**Symptoms:**
- Device scanned QR code successfully
- Status stuck in "pending"
- No token received

**Diagnosis:**
1. Check admin dashboard: Is device listed?
2. Verify admin has approved device
3. Check device polling logic (should poll every 5 seconds)

**Resolution:**
- Admin must click ✅ Approve button
- Device will receive token on next poll

### Device Cannot Scan (403 Forbidden)

**Symptoms:**
- Scan request returns `403 Forbidden`
- Error message: "Device is blocked" or "Device is pending"

**Diagnosis:**
1. Check device status in admin dashboard
2. Verify JWT token is present
3. Check database for device record

**Resolution:**
- If pending: Admin must approve device
- If blocked: Admin must unblock device
- If active: Check JWT token validity

### QR Code Won't Generate

**Symptoms:**
- Admin clicks "Show Pairing QR"
- Error: "Server identity not initialized"

**Diagnosis:**
1. Check server logs for identity initialization
2. Verify `.eck/server_identity.json` exists
3. Check file permissions on `.eck/` directory

**Resolution:**
```bash
# Restart server to regenerate identity
sudo systemctl restart eckwms

# Verify identity file
cat .eck/server_identity.json
```

### Invalid Signature Error

**Symptoms:**
- Device registration fails
- Error: "Invalid signature"

**Diagnosis:**
1. Check device clock (must be synchronized)
2. Verify message format matches spec
3. Check public key encoding (must be Base64)

**Resolution:**
- Device: Sync clock via NTP
- Device: Verify signature implementation
- Server: Check logs for signature verification details

### Token Not Accepted

**Symptoms:**
- Device has token but API calls fail
- Error: "Unauthorized" or "Invalid token"

**Diagnosis:**
1. Check JWT expiration
2. Verify token format (Bearer prefix)
3. Check server secret key consistency

**Resolution:**
- Device: Request new token via re-registration
- Server: Verify JWT secret hasn't changed
- Server: Check token validation logic in middleware

---

## API Reference

### GET /api/internal/pairing-qr

Generate pairing QR code.

**Authentication:** Required (Admin JWT)

**Response:**
- Content-Type: `image/png`
- Body: PNG image (512x512 pixels)

**Example:**
```bash
curl -H "Authorization: Bearer $TOKEN" \
     https://pda.repair/E/api/internal/pairing-qr \
     --output pairing-qr.png
```

### POST /api/internal/register-device

Device registration and token acquisition.

**Authentication:** None (verified by signature)

**Request:**
```json
{
  "deviceId": "uuid",
  "deviceName": "Scanner-01",
  "devicePublicKey": "base64-encoded-key",
  "signature": "base64-encoded-signature"
}
```

**Response:**
```json
{
  "success": true,
  "status": "pending|active|blocked",
  "token": "jwt-token-or-empty",
  "message": "Device handshake complete"
}
```

### GET /api/admin/devices

List all registered devices.

**Authentication:** Required (Admin JWT)

**Response:**
```json
[
  {
    "deviceId": "uuid",
    "name": "Scanner-01",
    "publicKey": "base64-key",
    "status": "active",
    "lastSeenAt": "2026-01-25T10:35:44Z",
    "createdAt": "2026-01-25T09:00:00Z",
    "updatedAt": "2026-01-25T10:35:44Z"
  }
]
```

### PUT /api/admin/devices/{id}/status

Update device status.

**Authentication:** Required (Admin JWT)

**Request:**
```json
{
  "status": "active|pending|blocked"
}
```

**Response:**
```json
{
  "deviceId": "uuid",
  "name": "Scanner-01",
  "status": "active",
  ...
}
```

---

## Android App Integration

### Scanning QR Code

```kotlin
// Parse QR code
val parts = qrContent.split("$")
if (parts[0] != "ECK" || parts[1] != "1") {
    throw Exception("Invalid protocol")
}

val serverUuid = parts[2]
val serverPublicKey = parts[3].decodeHex()
val serverUrl = parts[4]
```

### Generating Keypair

```kotlin
import net.i2p.crypto.eddsa.EdDSAPrivateKey
import net.i2p.crypto.eddsa.EdDSAPublicKey
import net.i2p.crypto.eddsa.KeyPairGenerator

val keyPair = KeyPairGenerator().generateKeyPair()
val publicKey = keyPair.public as EdDSAPublicKey
val privateKey = keyPair.private as EdDSAPrivateKey
```

### Signing Message

```kotlin
import net.i2p.crypto.eddsa.EdDSAEngine

val message = """{"deviceId":"$deviceId","devicePublicKey":"$publicKeyBase64"}"""
val signature = EdDSAEngine(MessageDigest.getInstance("SHA-512"))
    .apply { initSign(privateKey) }
    .run {
        update(message.toByteArray())
        sign()
    }
```

### Registration Request

```kotlin
val request = JSONObject().apply {
    put("deviceId", deviceId)
    put("deviceName", Build.MODEL)
    put("devicePublicKey", publicKeyBase64)
    put("signature", signatureBase64)
}

val response = httpClient.post("$serverUrl/api/internal/register-device") {
    setBody(request.toString())
}
```

### Token Storage

```kotlin
// On successful registration with active status
if (response.status == "active" && response.token.isNotEmpty()) {
    // Store token securely
    securePreferences.edit()
        .putString("auth_token", response.token)
        .putString("device_id", deviceId)
        .putString("server_url", serverUrl)
        .apply()
}
```

---

## Performance Considerations

### Signature Verification

- **Throughput:** ~70,000 verifications/second
- **Latency:** <1ms per verification
- **CPU Impact:** Negligible on modern hardware

### Database Lookups

- **Real-time Status Check:** 1 query per API request
- **Optimization:** Index on `device_id` (primary key)
- **Latency:** <5ms typical

### QR Code Generation

- **Encoding:** 512x512 PNG, Medium error correction
- **Generation Time:** ~50ms
- **Caching:** Not implemented (generated on-demand)

---

## Migration & Upgrades

### From Legacy Node.js System

The Go implementation maintains compatibility with the legacy ECK-P1-ALPHA protocol:

- ✅ Same QR code format
- ✅ Same signature scheme (Ed25519)
- ✅ Same API endpoints
- ✅ Same status workflow

**Migration Steps:**
1. Export device list from Node.js database
2. Import into Go PostgreSQL (RegisteredDevice table)
3. Server identity can be migrated or regenerated
4. Existing devices must re-register (new keypairs)

### Future Protocol Versions

**ECK-P2 (Planned):**
- Certificate pinning
- Mutual TLS
- Device attestation
- Hardware security module (HSM) support

---

## Compliance & Auditing

### Data Retention

- Device records: Soft-deleted (retained for audit)
- Last seen timestamps: Updated on each API call
- Public keys: Stored indefinitely

### Audit Trail

**Logged Events:**
- Device registration attempts
- Admin approval/blocking actions
- Failed authentication attempts
- Status changes

**Log Format:**
```
2026-01-25T10:35:44Z [INFO] Device registered: device_id=550e8400... status=pending
2026-01-25T10:36:12Z [INFO] Device approved: device_id=550e8400... admin=user@example.com
2026-01-25T11:42:33Z [WARN] Blocked device scan attempt: device_id=550e8400... status=blocked
```

---

## References

- [Ed25519 Specification (RFC 8032)](https://datatracker.ietf.org/doc/html/rfc8032)
- [JWT Specification (RFC 7519)](https://datatracker.ietf.org/doc/html/rfc7519)
- [OWASP Authentication Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Authentication_Cheat_Sheet.html)

---

**Document Version:** 1.0
**Last Updated:** 2026-01-25
**Maintainer:** Development Team
